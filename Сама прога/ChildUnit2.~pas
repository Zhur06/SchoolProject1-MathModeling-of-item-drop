unit ChildUnit2;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, ExtCtrls;

type
  Arr = array of array [1..4] of real;                                          //1 - скорость по x 2 - скорость по y 3 - координата x 4 - координата y

  TChildForm2 = class(TForm)
    PaintBox1: TPaintBox;
    procedure PaintBox1Paint(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    function MathOfNoAtmosfereFlight(var maxx, maxy, Gmaxx, Gmaxy: real; var j2, t: integer): Arr;
  private
    { Private declarations }
  public
    t: integer;
    A: array of Arr;
    { Public declarations }
  end;

var
  ChildForm2: TChildForm2;

implementation

uses MainUnit;

{$R *.dfm}

procedure TChildForm2.FormClose(Sender: TObject; var Action: TCloseAction);
begin
    Action := caFree;
    MainForm.CF2 :=  MainForm.CF2 - 1;
end;

//################# РАССЧЕТЫ ###################################################

function TChildForm2.MathOfNoAtmosfereFlight(var maxx, maxy, Gmaxx, Gmaxy: real; var j2, t: integer): Arr;
var counter: integer;
begin
  SetLength(Result, 1);
  Result[0][1] := MainForm.pictureA[j2].V * cos(MainForm.pictureA[j2].al * pi/180);                            //Переводим данную нам скорость на ее проекции на оси плоскости
  Result[0][2] := MainForm.pictureA[j2].V * sin(MainForm.pictureA[j2].al * pi/180);

  Result[0][3] := 0;
  Result[0][4] := 0;

  t := 0;

  Repeat
    SetLength(Result, length(Result) + 1);
    t := t + 1;

    Result[t][1] := Result[t - 1][1];                                                   //Рассчет координат нового вектора скорости
    Result[t][2] := Result[0][2] - (10 * t);

    Result[t][3] := Result[t - 1][3] + Result[t][1];                                           //Рассчет координат тела
    Result[t][4] := Result[t - 1][4] + Result[t][2];
  Until Result[t][4] <= 0;

  For counter := 0 to t do                                                      //нахождение максимальных значений x и y
  begin
    if Result[counter][3] > maxx then
      maxx := Result[counter][3];
    if Result[counter][4] > maxy then
      maxy := Result[counter][4];
  end;

  if maxx > Gmaxx then
    Gmaxx := maxx;
  if maxy > Gmaxy then
    Gmaxy := maxy;
end;

//-------------------------Отрисовка--------------------------------------------

procedure TChildForm2.PaintBox1Paint(Sender: TObject);
var counter, j2: integer; maxx, maxy, Gmaxx, Gmaxy: real;
begin

SetLength(A, length(MainForm.pictureA));

For j2 := 0 to length(MainForm.pictureA) - 1 do
  A[j2] := MathOfNoAtmosfereFlight(maxx, maxy, Gmaxx, Gmaxy, j2, t);

PatBlt(ChildForm2.PaintBox1.Canvas.Handle, 0, 0, ChildForm2.ClientWidth, ChildForm2.ClientHeight, WHITENESS);
For j2 := 0 to length(MainForm.pictureA) - 1 do
begin
  if t <> 0 then
  With PaintBox1, Canvas do
  begin
    Brush.Color := clWhite;                                                     //Установка цвета кисти
    Pen.Color := MainForm.pictureA[j2].color;
    Pen.Width := 1;
    Pen.Style := psSolid;

    MoveTo(0, Height);                                                          //Перемещение начала линии в левый нижний угол

  if MainForm.ScaleCB.Checked then
    For counter := 0 to t do
    begin
      if Width >= Height then
        LineTo(Round((Width / Gmaxx) * A[j2][counter][3]), Round(Height - ((Width / Gmaxx) * A[j2][counter][4])))
      else
        LineTo(Round((Height / Gmaxx) * A[j2][counter][3]), Round(Height - ((Height / Gmaxx) *  A[j2][counter][4])));
    end
  else
    For counter := 0 to t do
    begin
      LineTo(Round(A[j2][counter][3]), Round(Height - A[j2][counter][4]));
    end;
  end;
end;  
end;
end.
